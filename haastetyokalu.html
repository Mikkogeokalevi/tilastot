<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geokätköilyn Haastetyökalu</title>
    
    <style>
        body{background-color:#1a2015;font-family:'Georgia',serif;margin:0;padding:20px;transition:padding .3s ease}.sisalto-laatikko{max-width:950px;margin:30px auto;padding:10px;background-color:#3D4F2B;border:3px solid #11150C;border-radius:12px;box-shadow:5px 5px 15px rgba(0,0,0,.6);transition:margin .3s ease}.teksti-alue{color:#F8F8F8;line-height:1.8;padding:10px;font-size:1.1em;transition:font-size .3s ease}.logo{width:120px;height:120px;border:2px solid #90EE90;border-radius:50%;box-shadow:1px 1px 3px rgba(0,0,0,.4);background-color:#3D4F2B;padding:3px}.paaotsikko{color:#90EE90;text-align:center;margin:0;text-shadow:1px 1px 2px rgba(0,0,0,.8);font-size:1.6em;letter-spacing:.5px}.leipateksti{margin:15px 0;color:#FFFFFF;font-size:1.2em}.valinnat-laatikko{background-color:#2A381C;padding:15px;border-radius:8px;margin:20px 0;border:1px dashed #90EE90}.valinnat-laatikko label{margin-right:20px;font-size:1.1em;cursor:pointer;display:inline-block;margin-bottom:10px;min-width:150px}.valinnat-laatikko input{vertical-align:middle;margin-right:5px}#zip-input-container{margin:20px 0}#zip-input{font-size:1.1em}#export-button{font-size:1em;padding:8px 12px;margin-top:10px;background-color:#90EE90;color:#11150C;border:none;border-radius:5px;cursor:pointer}#export-button:hover{background-color:#7CFC00}#status{font-weight:700;min-height:25px;color:#FFD700}.grid-container{overflow-x:auto}.grid-container table{border-collapse:collapse;margin-top:15px;margin-bottom:15px;width:100%}.grid-container td,.grid-container th{border:1px solid #90EE90;text-align:center;padding:5px;font-size:.9em}.grid-container th{background-color:#2A381C}.grid-container td.found{background-color:#90ee90;color:#114e11;font-weight:700}.grid-container td.not-found{background-color:rgba(0,0,0,.2)}.grid-container ul{list-style-type:none;padding-left:0;columns:2;gap:20px}.grid-container h4{color:#90EE90;margin-top:20px}.suodatus-paneeli{background-color:#2A381C;padding:20px;border-radius:8px;margin:20px 0;border:1px dashed #90EE90;display:flex;flex-wrap:wrap;gap:20px;align-items:flex-end;}.suodatus-paneeli .filter-group{display:flex;flex-direction:column}.suodatus-paneeli label{font-size:.9em;color:#90EE90;margin-bottom:5px}.suodatus-paneeli select, .suodatus-paneeli input[type=date], .suodatus-paneeli button{font-size:1em;padding:5px;background-color:#F8F8F8;border:1px solid #90EE90;border-radius:4px}
        
        .total-cell, .total-row th { background-color: #2E441E !important; }
        .grand-total { background-color: #C00000 !important; color: white !important; font-weight: bold; }

        .dt-grid-wrapper { position: relative; padding-top: 30px; padding-left: 50px; }
        .dt-label { position: absolute; color: #90EE90; font-weight: bold; }
        .dt-label-top { top: 0; left: 50%; transform: translateX(-50%); }
        .dt-label-side { left: 0; top: 50%; transform: translateY(-50%) rotate(-90deg); }
        #fizzy-grid table { border-spacing: 1px; border-collapse: separate; border: none; }
        #fizzy-grid td, #fizzy-grid th { border: none; }
        #fizzy-grid td.not-found { background-color: #2A381C; }
        
        #status-timestamp { display: block; font-size: 0.8em; color: #ccc; margin-top: 5px; font-weight: normal; }
        
        .header-flex-container { display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
        
        #update-data-link { font-size: 0.9em; margin-left: 20px; color: #90EE90; }
        .filter-summary { font-size: 0.8em; font-style: italic; color: #ccc; margin-bottom: -10px; margin-top: 5px; }

        #attribute-modal { background-color: #3D4F2B; color: white; border: 2px solid #90EE90; border-radius: 8px; max-width: 800px; }
        #attribute-modal::backdrop { background: rgba(0, 0, 0, 0.7); }
        .attribute-columns { display: flex; gap: 40px; }
        .attribute-column { flex: 1; }
        .attribute-column h4 { color: #90EE90; border-bottom: 1px solid #90EE90; padding-bottom: 5px; margin-top: 20px; margin-bottom: 10px; }
        .attribute-column label { display: block; margin-bottom: 5px; cursor: pointer; }
        .modal-buttons { margin-top: 20px; text-align: right; }
        .modal-buttons button { margin-left: 10px; }


        @media (max-width:768px){body{padding:10px}.sisalto-laatikko{margin:15px auto}.teksti-alue{font-size:1em}.paaotsikko{font-size:1.4em}.leipateksti{font-size:1.1em}.grid-container ul{columns:1}.grid-container td,.grid-container th{padding:4px;font-size:.85em;min-width:30px}.grid-container thead th{position:-webkit-sticky;position:sticky;top:0;z-index:2}.grid-container tbody th{position:-webkit-sticky;position:sticky;left:0;background-color:#3D4F2B;z-index:1}.grid-container thead th:first-child{z-index:3}.attribute-columns {flex-direction: column;}}
    </style>
</head>
<body>
    <div class="sisalto-laatikko">
        <div class="teksti-alue">

            <div class="header-flex-container">
                <img src="https://img.geocaching.com:443/84454fa6-e23a-4aad-a8a4-612b77f23abe.png" alt="Oma logo" class="logo" />
                <h3 class="paaotsikko">— Geokätköilyn Haastetyökalu —</h3>
            </div>
            
            <p class="leipateksti" id="instruction-text">
                Lataa "My Finds" .zip-tiedostosi, valitse haluamasi haasteet ja suodattimet, ja näe edistymisesi välittömästi.
            </p>
            
            <div class="suodatus-paneeli" id="filter-panel" style="display: none;">
                <div class="filter-group"><label for="filter-start-date">Alkupvm</label><input type="date" id="filter-start-date" class="filter-select"></div>
                <div class="filter-group"><label for="filter-end-date">Loppupvm</label><input type="date" id="filter-end-date" class="filter-select"></div>
                <div class="filter-group"><label for="filter-year">Vuosi</label><select id="filter-year" class="filter-select"></select></div>
                <div class="filter-group"><label for="filter-month">Kuukausi</label><select id="filter-month" class="filter-select"><option value="all">Kaikki</option><option value="0">Tammi</option><option value="1">Helmi</option><option value="2">Maalis</option><option value="3">Huhti</option><option value="4">Touko</option><option value="5">Kesä</option><option value="6">Heinä</option><option value="7">Elo</option><option value="8">Syys</option><option value="9">Loka</option><option value="10">Marras</option><option value="11">Joulu</option></select></div>
                <div class="filter-group"><label for="filter-weekday">Viikonpäivä</label><select id="filter-weekday" class="filter-select"><option value="all">Kaikki</option><option value="1">Maanantai</option><option value="2">Tiistai</option><option value="3">Keskiviikko</option><option value="4">Torstai</option><option value="5">Perjantai</option><option value="6">Lauantai</option><option value="0">Sunnuntai</option></select></div>
                <div class="filter-group"><label for="filter-type">Kätkötyyppi</label><select id="filter-type" class="filter-select"></select></div>
                <div class="filter-group"><label for="filter-country">Maa</label><select id="filter-country" class="filter-select"></select></div>
                <div class="filter-group"><label for="attribute-filter-btn">Attribuutit</label><button id="attribute-filter-btn">Valitse (0)</button></div>
            </div>

            <div class="valinnat-laatikko">
                <p class="leipateksti" style="margin-top:0; margin-bottom:10px; font-size: 1.1em;">Valitse näytettävät tilastot:</p>
                <label><input type="checkbox" id="chk-fizzy" class="challenge-checkbox" checked> D/T-taulukko</label>
                <label><input type="checkbox" id="chk-calendar" class="challenge-checkbox" checked> Kalenteri</label>
                <label><input type="checkbox" id="chk-jasmer" class="challenge-checkbox" checked> Jasmer</label>
                <label><input type="checkbox" id="chk-yearmonth" class="challenge-checkbox"> Vuosi/kk-matriisi</label>
                <label><input type="checkbox" id="chk-streak" class="challenge-checkbox"> Löytöputki</label>
                <label><input type="checkbox" id="chk-typesize" class="challenge-checkbox"> Tyyppi & Koko</label>
                <label><input type="checkbox" id="chk-owners" class="challenge-checkbox"> Omistajat (Top 30)</label>
                <label><input type="checkbox" id="chk-countries" class="challenge-checkbox"> Maat</label>
                <label><input type="checkbox" id="chk-attributes" class="challenge-checkbox"> Attribuutit</label>
            </div>
            
            <div id="zip-input-container">
                <input type="file" id="zip-input" accept=".zip">
                <button id="export-button" style="display: none;">Tallenna data (JSON)</button>
            </div>
            <div id="status">
                <span id="status-counts">Etsitään valmiiksi tallennettua dataa...</span>
                <a href="#" id="update-data-link" style="display: none;">Päivitä data uudella .zip-tiedostolla</a>
                <span id="status-timestamp"></span>
            </div>

            <div id="results-container" style="display: none;">
            </div>
        </div>
    </div>
    
    <dialog id="attribute-modal">
        <h3>Valitse suodatettavat attribuutit</h3>
        <p>Tilastot näyttävät kätköt, joilla on KAIKKI valitsemasi attribuutit.</p>
        <div class="attribute-columns">
            <div class="attribute-column" id="attribute-col-positive"></div>
            <div class="attribute-column" id="attribute-col-negative"></div>
        </div>
        <div class="modal-buttons">
            <button id="attribute-clear-btn">Tyhjennä valinnat</button>
            <button id="attribute-confirm-btn">Valmis</button>
        </div>
    </dialog>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let allParsedFinds = [];
        let gpxCreationDate = null;
        let attributeMap = new Map();

        const attributeModal = document.getElementById('attribute-modal');
        document.getElementById('attribute-filter-btn').addEventListener('click', () => attributeModal.showModal());
        document.getElementById('attribute-confirm-btn').addEventListener('click', () => {
            attributeModal.close();
            runAnalysis();
        });
        document.getElementById('attribute-clear-btn').addEventListener('click', () => {
            document.querySelectorAll('#attribute-modal input[type="checkbox"]').forEach(cb => cb.checked = false);
            updateAttributeButtonText();
        });
        attributeModal.addEventListener('change', updateAttributeButtonText);

        document.addEventListener('DOMContentLoaded', loadInitialData);
        document.getElementById('zip-input').addEventListener('change', handleFileSelect, false);
        document.getElementById('export-button').addEventListener('click', exportDataAsJson, false);
        document.querySelectorAll('.filter-select, .challenge-checkbox').forEach(element => {
            element.addEventListener('change', () => runAnalysis());
        });
        document.getElementById('update-data-link').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('zip-input-container').style.display = 'block';
            document.getElementById('instruction-text').style.display = 'block';
            document.getElementById('update-data-link').style.display = 'none';
        });
        
        async function loadInitialData() {
            try {
                const response = await fetch('my_finds_data.json');
                if (!response.ok) throw new Error('Etä-JSON-dataa ei löytynyt.');
                const data = await response.json();
                setupAndRun(data.finds, data.creationDate, "etätiedostosta (GitHub)");
            } catch (error) {
                console.log(error.message);
                updateStatusText(null, null, 'Valitse .zip-tiedosto aloittaaksesi.');
            }
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            updateStatusText(null, null, 'Käsitellään tiedostoa...');
            document.getElementById('results-container').style.display = 'none';
            document.getElementById('filter-panel').style.display = 'none';
            document.getElementById('export-button').style.display = 'none';
            try {
                const jszip = new JSZip();
                const zip = await jszip.loadAsync(file);
                let gpxContents = [];
                zip.forEach(async (relativePath, zipEntry) => {
                    if (zipEntry.name.toLowerCase().endsWith('.gpx') && !zipEntry.dir) gpxContents.push(zipEntry.async('string'));
                });
                if (gpxContents.length === 0) throw new Error('ZIP-tiedosto ei sisältänyt yhtään .gpx-tiedostoa.');
                const allGpx = await Promise.all(gpxContents);
                updateStatusText(null, null, 'Jäsennetään GPX-dataa...');
                await new Promise(resolve => setTimeout(resolve, 50));
                const parsedResult = parseGpxFiles(allGpx);
                setupAndRun(parsedResult.finds, parsedResult.creationDate, "ladatusta .zip-tiedostosta");
                document.getElementById('export-button').style.display = 'inline-block';
            } catch (error) {
                updateStatusText(null, null, 'Virhe: ' + error.message);
                console.error(error);
            }
        }
        
        function setupAndRun(findsData, creationDateData, sourceType) {
            allParsedFinds = findsData.map(find => ({ ...find, findDate: new Date(find.findDate), placedDate: new Date(find.placedDate) }));
            gpxCreationDate = creationDateData ? new Date(creationDateData) : new Date();
            document.getElementById('zip-input-container').style.display = 'none';
            document.getElementById('instruction-text').style.display = 'none';
            document.getElementById('update-data-link').style.display = 'inline';
            updateStatusText(allParsedFinds.length, allParsedFinds.length, `Ladattu ${allParsedFinds.length} löytöä ${sourceType}.`);
            populateFilterOptions();
            runAnalysis();
        }
        
        function exportDataAsJson() {
            if (allParsedFinds.length === 0) { alert('Ei dataa tallennettavaksi.'); return; }
            const dataToSave = { finds: allParsedFinds, creationDate: gpxCreationDate };
            const dataStr = JSON.stringify(dataToSave);
            const dataBlob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'my_finds_data.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function runAnalysis() {
            if (allParsedFinds.length === 0) return;
            const filteredFinds = getFilteredFinds(); 
            const resultsEl = document.getElementById('results-container');
            updateStatusText(filteredFinds.length, allParsedFinds.length);
            resultsEl.style.display = 'block';
            resultsEl.innerHTML = '';
            const filterSummary = getFilterSummaryText();
            const renderMap = {
                'chk-fizzy': { container: 'fizzy-container', grid: 'fizzy-grid', title: 'D/T-taulukko', render: renderFizzyGrid },
                'chk-calendar': { container: 'calendar-container', grid: 'calendar-grid', title: 'Calendar Challenge (365 päivää)', render: renderCalendarGrid },
                'chk-jasmer': { container: 'jasmer-container', grid: 'jasmer-grid', title: 'Jasmer Challenge (Piilotuskuukaudet)', render: renderJasmerGrid },
                'chk-yearmonth': { container: 'year-month-container', grid: 'year-month-grid', title: 'Löytömatriisi (Vuosi/Kuukausi)', render: renderYearMonthGrid },
                'chk-streak': { container: 'streak-container', grid: 'streak-stats-grid', title: 'Pisin löytöputki', render: renderStreakStats },
                'chk-typesize': { container: 'type-size-stats-container', grid: 'type-size-stats-grid', title: 'Kätkötyypit ja -koot', render: renderTypeAndSizeStats },
                'chk-owners': { container: 'owner-stats-container', grid: 'owner-stats-grid', title: 'Löydöt omistajittain (Top 30)', render: renderOwnerStats },
                'chk-countries': { container: 'country-stats-container', grid: 'country-stats-grid', title: 'Löydöt maittain', render: renderCountryStats },
                'chk-attributes': { container: 'attributes-container', grid: 'attributes-grid', title: 'Attribuuttihaaste', render: renderAttributeGrid }
            };
            for (const id in renderMap) {
                if (document.getElementById(id) && document.getElementById(id).checked) {
                    const config = renderMap[id];
                    resultsEl.innerHTML += `<div id="${config.container}"><h2>${config.title}</h2><p class="filter-summary">${filterSummary}</p><div id="${config.grid}" class="grid-container"></div></div>`;
                    try {
                        config.render(filteredFinds);
                    } catch (e) {
                        console.error(`Virhe renderöidessä: ${config.title}`, e);
                        document.getElementById(config.grid).innerHTML = `<p style="color: red;">Tilaston lataus epäonnistui. Virhe lokissa.</p>`;
                    }
                }
            }
        }
        
        function getFilterSummaryText() {
            let parts = [];
            const startDate = document.getElementById('filter-start-date').value;
            const endDate = document.getElementById('filter-end-date').value;
            const year = document.getElementById('filter-year');
            const month = document.getElementById('filter-month');
            const weekday = document.getElementById('filter-weekday');
            const type = document.getElementById('filter-type');
            const country = document.getElementById('filter-country');
            const selectedAttrs = document.querySelectorAll('#attribute-modal input:checked');

            if (startDate || endDate) {
                const start = startDate ? new Date(startDate).toLocaleDateString('fi-FI') : '...';
                const end = endDate ? new Date(endDate).toLocaleDateString('fi-FI') : '...';
                parts.push(`Aikaväli: ${start} - ${end}`);
            }
            if (year.value !== 'all') parts.push(`Vuosi: ${year.options[year.selectedIndex].text}`);
            if (month.value !== 'all') parts.push(`Kuukausi: ${month.options[month.selectedIndex].text}`);
            if (weekday.value !== 'all') parts.push(`Viikonpäivä: ${weekday.options[weekday.selectedIndex].text}`);
            if (type.value !== 'all') parts.push(`Tyyppi: ${type.options[type.selectedIndex].text}`);
            if (country.value !== 'all') parts.push(`Maa: ${country.options[country.selectedIndex].text}`);
            if (selectedAttrs.length > 0) {
                let attrNames = Array.from(selectedAttrs).map(cb => cb.dataset.name).slice(0, 2);
                let attrPart = `Attribuutit: ${attrNames.join(', ')}`;
                if (selectedAttrs.length > 2) attrPart += `... (+${selectedAttrs.length - 2})`;
                parts.push(attrPart);
            }

            if (parts.length === 0) return "Suodattimet: Kaikki";
            return "Suodattimet: " + parts.join('; ');
        }

        function updateAttributeButtonText() {
            const count = document.querySelectorAll('#attribute-modal input:checked').length;
            document.getElementById('attribute-filter-btn').textContent = `Valitse (${count})`;
        }

        function updateStatusText(filteredCount, totalCount, overrideText) {
            const countsEl = document.getElementById('status-counts');
            const timestampEl = document.getElementById('status-timestamp');
            if (overrideText) {
                countsEl.innerHTML = overrideText;
                timestampEl.textContent = '';
                return;
            }
            let statusText = '';
            if (totalCount !== null && typeof totalCount !== 'undefined') {
                statusText = `Näytetään ${filteredCount} / ${totalCount} löydöstä.`;
            } else {
                 statusText = 'Valitse .zip-tiedosto aloittaaksesi.';
            }
            countsEl.innerHTML = statusText;
            if (gpxCreationDate) {
                timestampEl.textContent = `Datan lähde luotu: ${gpxCreationDate.toLocaleString('fi-FI')}`;
            } else {
                timestampEl.textContent = '';
            }
        }

        function populateFilterOptions() {
            const typeSelect = document.getElementById('filter-type');
            const countrySelect = document.getElementById('filter-country');
            const yearSelect = document.getElementById('filter-year');
            
            const types = [...new Set(allParsedFinds.map(f => f.type))].sort();
            const countries = [...new Set(allParsedFinds.map(f => f.country).filter(c => c !== 'N/A'))].sort();
            const years = [...new Set(allParsedFinds.map(f => f.findDate.getFullYear()))].sort((a, b) => b - a);

            yearSelect.innerHTML = '<option value="all">Kaikki</option>';
            typeSelect.innerHTML = '<option value="all">Kaikki</option>';
            countrySelect.innerHTML = '<option value="all">Kaikki</option>';
            
            years.forEach(year => yearSelect.innerHTML += `<option value="${year}">${year}</option>`);
            types.forEach(type => typeSelect.innerHTML += `<option value="${type}">${type}</option>`);
            countries.forEach(country => countrySelect.innerHTML += `<option value="${country}">${country}</option>`);
            
            attributeMap.clear();
            allParsedFinds.forEach(find => {
                find.attributes.forEach(attr => {
                    const key = `${attr.id}_${attr.inc}`;
                    if (!attributeMap.has(key)) {
                        attributeMap.set(key, { id: attr.id, inc: attr.inc, name: attr.name });
                    }
                });
            });

            const positiveCol = document.getElementById('attribute-col-positive');
            const negativeCol = document.getElementById('attribute-col-negative');
            let positiveHtml = '<h4>Kyllä / Päällä</h4>';
            let negativeHtml = '<h4>Ei / Pois päältä</h4>';
            
            const sortedAttributes = [...attributeMap.values()].sort((a,b) => a.name.localeCompare(b.name));

            sortedAttributes.forEach(attrData => {
                const checkbox = `<label><input type="checkbox" value="${attrData.id}_${attrData.inc}" data-name="${attrData.name}"> ${attrData.name}</label>`;
                if (attrData.inc) {
                    positiveHtml += checkbox;
                } else {
                    negativeHtml += checkbox;
                }
            });
            
            positiveCol.innerHTML = positiveHtml;
            negativeCol.innerHTML = negativeHtml;

            document.getElementById('filter-panel').style.display = 'flex';
        }

        function getFilteredFinds() {
            const startDateValue = document.getElementById('filter-start-date').value;
            const endDateValue = document.getElementById('filter-end-date').value;
            const year = document.getElementById('filter-year').value;
            const month = document.getElementById('filter-month').value;
            const weekday = document.getElementById('filter-weekday').value;
            const type = document.getElementById('filter-type').value;
            const country = document.getElementById('filter-country').value;
            const selectedAttrCheckboxes = document.querySelectorAll('#attribute-modal input:checked');
            const selectedAttributes = Array.from(selectedAttrCheckboxes).map(cb => cb.value);

            let filteredFinds = allParsedFinds;
            
            if (startDateValue) {
                const startDate = new Date(startDateValue);
                startDate.setHours(0, 0, 0, 0);
                filteredFinds = filteredFinds.filter(f => f.findDate >= startDate);
            }
            if (endDateValue) {
                const endDate = new Date(endDateValue);
                endDate.setHours(23, 59, 59, 999);
                filteredFinds = filteredFinds.filter(f => f.findDate <= endDate);
            }
            if (year !== 'all') { filteredFinds = filteredFinds.filter(f => f.findDate.getFullYear() == year); }
            if (month !== 'all') { filteredFinds = filteredFinds.filter(f => f.findDate.getMonth() == month); }
            if (weekday !== 'all') { filteredFinds = filteredFinds.filter(f => f.findDate.getDay() == weekday); }
            if (type !== 'all') { filteredFinds = filteredFinds.filter(f => f.type === type); }
            if (country !== 'all') { filteredFinds = filteredFinds.filter(f => f.country === country); }
            
            if (selectedAttributes.length > 0) {
                filteredFinds = filteredFinds.filter(find => {
                    const findAttrs = new Set(find.attributes.map(a => `${a.id}_${a.inc}`));
                    return selectedAttributes.every(sa => findAttrs.has(sa));
                });
            }
            return filteredFinds;
        }

        function parseGpxFiles(gpxStrings) {
            const finds = [];
            const parser = new DOMParser();
            const acceptedLogTypes = ['found it', 'attended', 'webcam photo taken', 'virtually visited', 'webhook posted'];
            let creationDate = null;
            if (gpxStrings.length > 0) {
                try {
                    const firstXmlDoc = parser.parseFromString(gpxStrings[0], "application/xml");
                    const timeNode = firstXmlDoc.querySelector('gpx > time, *|gpx > *|time');
                    if (timeNode) creationDate = new Date(timeNode.textContent);
                } catch(e) { console.error("Could not parse creation date from GPX header.", e); }
            }
            gpxStrings.forEach(gpxString => {
                try {
                    const xmlDoc = parser.parseFromString(gpxString, "application/xml");
                    const waypoints = xmlDoc.getElementsByTagName('wpt');
                    for (const wpt of waypoints) {
                        const cacheNode = wpt.querySelector('groundspeak\\:cache, *|cache');
                        if (!cacheNode) continue;
                        const logNodes = wpt.querySelectorAll('groundspeak\\:log, *|log');
                        if (logNodes.length === 0) continue;
                        let foundLogNode = null;
                        for (const aLogNode of logNodes) {
                            const logTypeText = aLogNode.querySelector('groundspeak\\:type, *|type')?.textContent?.trim().toLowerCase();
                            if (logTypeText && acceptedLogTypes.includes(logTypeText)) {
                                foundLogNode = aLogNode;
                                break; 
                            }
                        }
                        if (foundLogNode) {
                            const getText = (node, query) => node?.querySelector(query)?.textContent ?? 'N/A';
                            const cacheType = getText(cacheNode, 'groundspeak\\:type, *|type');
                            let country = getText(cacheNode, 'groundspeak\\:country, *|country');
                            if (cacheType === 'Locationless (Reverse) Cache') country = 'Paikaton';
                            const attributesNode = cacheNode.querySelector('groundspeak\\:attributes, *|attributes');
                            const findAttributes = [];
                            if (attributesNode) {
                                const attributeNodes = attributesNode.querySelectorAll('groundspeak\\:attribute, *|attribute');
                                attributeNodes.forEach(attr => {
                                    const incValue = attr.getAttribute('inc')?.toLowerCase();
                                    findAttributes.push({ id: attr.getAttribute('id'), inc: (incValue === '1' || incValue === 'true'), name: attr.textContent.trim() });
                                });
                            }
                            finds.push({
                                gcCode: getText(wpt, 'name, *|name'),
                                name: getText(cacheNode, 'groundspeak\\:name, *|name'),
                                type: cacheType,
                                container: getText(cacheNode, 'groundspeak\\:container, *|container'),
                                difficulty: parseFloat(getText(cacheNode, 'groundspeak\\:difficulty, *|difficulty').replace(',', '.')) || 0,
                                terrain: parseFloat(getText(cacheNode, 'groundspeak\\:terrain, *|terrain').replace(',', '.')) || 0,
                                owner: getText(cacheNode, 'groundspeak\\:owner, *|owner'),
                                country: country,
                                state: getText(cacheNode, 'groundspeak\\:state, *|state'),
                                findDate: new Date(getText(foundLogNode, 'groundspeak\\:date, *|date')),
                                placedDate: new Date(getText(wpt, 'time, *|time')),
                                attributes: findAttributes
                            });
                        }
                    }
                } catch (e) { console.error("GPX-tiedoston jäsennys epäonnistui.", e); }
            });
            return { finds: finds, creationDate: creationDate };
        }
        
        // --- RENDER-funktiot ---
        function renderFizzyGrid(finds) {
            const container = document.getElementById('fizzy-grid');
            if (!container) return;
            const dtCounts = new Map();
            finds.forEach(f => {
                const key = `${f.difficulty}_${f.terrain}`;
                dtCounts.set(key, (dtCounts.get(key) || 0) + 1);
            });
            const maxCount = Math.max(1, ...dtCounts.values());
            const difficulties = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5];
            const terrains = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5];
            const columnTotals = Array(terrains.length).fill(0);
            let tableHtml = '<table><thead><tr><th></th>';
            terrains.forEach(t => tableHtml += `<th>${t.toFixed(1)}</th>`);
            tableHtml += '<th class="total-cell">Yht.</th></tr></thead><tbody>';
            difficulties.forEach(d => {
                let rowTotal = 0;
                tableHtml += `<tr><th>${d.toFixed(1)}</th>`;
                terrains.forEach((t, tIndex) => {
                    const key = `${d}_${t}`;
                    const count = dtCounts.get(key) || 0;
                    rowTotal += count;
                    columnTotals[tIndex] += count;
                    if (count > 0) {
                        const percentage = Math.log(count + 1) / Math.log(maxCount + 1);
                        const lightness = 90 - (percentage * 50);
                        const textColor = lightness < 65 ? 'white' : 'black';
                        tableHtml += `<td class="found" style="background-color: hsl(90, 50%, ${lightness}%); color: ${textColor};">${count}</td>`;
                    } else {
                        tableHtml += `<td class="not-found"></td>`;
                    }
                });
                tableHtml += `<th class="total-cell">${rowTotal}</th>`;
                tableHtml += '</tr>';
            });
            tableHtml += '<tr class="total-row"><th>Yht.</th>';
            let grandTotal = 0;
            columnTotals.forEach(total => {
                tableHtml += `<th>${total}</th>`;
                grandTotal += total;
            });
            tableHtml += `<th class="grand-total">${grandTotal}</th>`;
            tableHtml += '</tr></tbody></table>';
            let finalHtml = `<div class="dt-grid-wrapper"><div class="dt-label dt-label-top">Maasto</div><div class="dt-label dt-label-side">Vaikeustaso</div>${tableHtml}</div>`;
            finalHtml += `<p class="leipateksti">Olet täyttänyt <strong>${dtCounts.size} / 81</strong> D/T-yhdistelmästä (valituilla suodattimilla).</p>`;
            container.innerHTML = finalHtml;
        }
        function renderCalendarGrid(finds) {
            const container = document.getElementById('calendar-grid');
            if (!container) return;
            const dayCounts = new Map();
            finds.forEach(f => {
                const key = `${(f.findDate.getMonth() + 1).toString().padStart(2, '0')}-${f.findDate.getDate().toString().padStart(2, '0')}`;
                dayCounts.set(key, (dayCounts.get(key) || 0) + 1);
            });
            const months = ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'];
            const dayTotals = Array(31).fill(0);
            let html = '<table><thead><tr><th></th>';
            for (let i = 1; i <= 31; i++) html += `<th>${i}</th>`;
            html += '<th class="total-cell">Yht.</th></tr></thead><tbody>';
            for (let i = 0; i < 12; i++) {
                let monthTotal = 0;
                html += `<tr><th>${months[i]}</th>`;
                for (let j = 1; j <= 31; j++) {
                    const date = new Date(2024, i, j);
                    if (date.getMonth() !== i) {
                        html += '<td style="background-color: #3D4F2B; border-color: #3D4F2B;"></td>';
                    } else {
                        const key = `${(i + 1).toString().padStart(2, '0')}-${j.toString().padStart(2, '0')}`;
                        const count = dayCounts.get(key) || 0;
                        monthTotal += count;
                        dayTotals[j-1] += count;
                        html += `<td class="${count > 0 ? 'found' : 'not-found'}">${count > 0 ? count : ''}</td>`;
                    }
                }
                html += `<th class="total-cell">${monthTotal}</th>`;
                html += '</tr>';
            }
            html += '<tr class="total-row"><th>Yht.</th>';
            let grandTotal = 0;
            dayTotals.forEach(total => {
                html += `<th>${total}</th>`;
                grandTotal += total;
            });
            html += `<th class="grand-total">${grandTotal}</th>`;
            html += '</tr></tbody></table>';
            const leapDayKey = '02-29';
            const foundLeapDay = dayCounts.has(leapDayKey);
            html += `<p class="leipateksti">Olet löytänyt kätkön <strong>${dayCounts.size}</strong> päivänä vuodesta. ${foundLeapDay ? `Karkauspäivänä löytöjä: <strong>${dayCounts.get(leapDayKey)}</strong> kpl!` : ''}</p>`;
            container.innerHTML = html;
        }
        function renderJasmerGrid(finds) {
            const container = document.getElementById('jasmer-grid');
            if (!container) return;
            const jasmerCounts = new Map();
            finds.filter(f => !f.type.toLowerCase().includes('event')).forEach(f => {
                const key = `${f.placedDate.getFullYear()}-${(f.placedDate.getMonth() + 1).toString().padStart(2, '0')}`;
                jasmerCounts.set(key, (jasmerCounts.get(key) || 0) + 1);
            });
            const startYear = 2000;
            const currentYear = new Date().getFullYear();
            const months = ['T', 'H', 'M', 'H', 'T', 'K', 'H', 'E', 'S', 'L', 'M', 'J'];
            let html = '<table><thead><tr><th>Vuosi</th>';
            months.forEach(m => html += `<th>${m}</th>`);
            html += '</tr></thead><tbody>';
            for (let year = startYear; year <= currentYear; year++) {
                html += `<tr><th>${year}</th>`;
                for (let month = 1; month <= 12; month++) {
                    if (year === 2000 && month < 5) {
                         html += '<td style="background-color: #3D4F2B; border-color: #3D4F2B;"></td>';
                         continue;
                    }
                    const key = `${year}-${month.toString().padStart(2, '0')}`;
                    const count = jasmerCounts.get(key) || 0;
                    html += `<td class="${count > 0 ? 'found' : 'not-found'}">${count > 0 ? count : ''}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody></table>';
            const now = new Date();
            const totalMonths = (now.getFullYear() - 2000 - 1) * 12 + (12 - 4) + (now.getMonth() + 1);
            html += `<p class="leipateksti">Olet löytänyt kätkön <strong>${jasmerCounts.size} / ${totalMonths}</strong> mahdollisesta piilotuskuukaudesta.</p>`;
            container.innerHTML = html;
        }
        function renderYearMonthGrid(finds) {
            const container = document.getElementById('year-month-grid');
            if (!container || finds.length === 0) { if (container) container.innerHTML = '<p>Ei löytöjä valituilla suodattimilla.</p>'; return; }
            const counts = new Map();
            let minYear = finds[0].findDate.getFullYear();
            let maxYear = minYear;
            finds.forEach(f => {
                const year = f.findDate.getFullYear();
                const month = f.findDate.getMonth();
                const key = `${year}-${month}`;
                counts.set(key, (counts.get(key) || 0) + 1);
                if (year < minYear) minYear = year;
                if (year > maxYear) maxYear = year;
            });
            const months = ['Tammi', 'Helmi', 'Maalis', 'Huhti', 'Touko', 'Kesä', 'Heinä', 'Elo', 'Syys', 'Loka', 'Marras', 'Joulu'];
            let html = '<table><thead><tr><th>Vuosi</th>';
            months.forEach(m => html += `<th>${m.substring(0,3)}</th>`);
            html += '<th>Yht.</th></tr></thead><tbody>';
            for (let year = maxYear; year >= minYear; year--) {
                let yearTotal = 0;
                html += `<tr><th>${year}</th>`;
                for (let month = 0; month < 12; month++) {
                    const count = counts.get(`${year}-${month}`) || 0;
                    yearTotal += count;
                    html += `<td>${count > 0 ? count : ''}</td>`;
                }
                html += `<th class="total-cell">${yearTotal}</th>`;
                html += '</tr>';
            }
            html += '</tbody></table>';
            container.innerHTML = html;
        }
        function renderStreakStats(finds) {
            const container = document.getElementById('streak-stats-grid');
            if (!container) return;
            if (finds.length === 0) { container.innerHTML = '<p>Ei löytöjä valituilla suodattimilla.</p>'; return; }
            const uniqueFindDays = [...new Set(finds.map(f => f.findDate.toISOString().split('T')[0]))];
            uniqueFindDays.sort();
            let longestStreak = 0;
            if (uniqueFindDays.length > 0) {
                longestStreak = 1;
                let currentStreak = 1;
                for (let i = 1; i < uniqueFindDays.length; i++) {
                    const currentDate = new Date(uniqueFindDays[i]);
                    const prevDate = new Date(uniqueFindDays[i - 1]);
                    const diffTime = currentDate - prevDate;
                    const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                    if (diffDays === 1) { currentStreak++; } else { if (currentStreak > longestStreak) longestStreak = currentStreak; currentStreak = 1; }
                }
                if (currentStreak > longestStreak) longestStreak = currentStreak;
            }
            container.innerHTML = `<p class="leipateksti">Pisin löytöputkesi on: <strong>${longestStreak} päivää</strong>.</p>`;
        }
        function renderTypeAndSizeStats(finds) {
            const container = document.getElementById('type-size-stats-grid');
            if (!container) return;
            const typeCounts = new Map();
            const sizeCounts = new Map();
            finds.forEach(f => {
                typeCounts.set(f.type, (typeCounts.get(f.type) || 0) + 1);
                sizeCounts.set(f.container, (sizeCounts.get(f.container) || 0) + 1);
            });
            const sortedTypes = [...typeCounts.entries()].sort((a, b) => b[1] - a[1]);
            const sortedSizes = [...sizeCounts.entries()].sort((a, b) => b[1] - a[1]);
            let html = '<h4>Kätkötyypit</h4><ul>';
            sortedTypes.forEach(([type, count]) => { html += `<li>${type}: <strong>${count}</strong></li>`; });
            html += '</ul><h4>Kätköjen koot</h4><ul>';
            sortedSizes.forEach(([size, count]) => { html += `<li>${size}: <strong>${count}</strong></li>`; });
            html += '</ul>';
            container.innerHTML = html;
        }
        function renderOwnerStats(finds) {
            const container = document.getElementById('owner-stats-grid');
            if (!container) return;
            const ownerCounts = new Map();
            finds.forEach(f => { if (f.owner && f.owner !== 'N/A') { ownerCounts.set(f.owner, (ownerCounts.get(f.owner) || 0) + 1); } });
            const sortedOwners = [...ownerCounts.entries()].sort((a, b) => b[1] - a[1]);
            let html = '<ul>';
            sortedOwners.slice(0, 30).forEach(([owner, count]) => { html += `<li>${owner}: <strong>${count}</strong></li>`; });
            html += '</ul>';
            container.innerHTML = html;
        }
        function renderCountryStats(finds) {
            const container = document.getElementById('country-stats-grid');
            if (!container) return;
            const countryCounts = new Map();
            finds.forEach(f => { if (f.country && f.country !== 'N/A') { countryCounts.set(f.country, (countryCounts.get(f.country) || 0) + 1); } });
            const sortedCountries = [...countryCounts.entries()].sort((a, b) => b[1] - a[1]);
            let html = '<ul>';
            sortedCountries.forEach(([country, count]) => { html += `<li>${country}: <strong>${count}</strong></li>`; });
            html += '</ul>';
            container.innerHTML = html;
        }
        function renderAttributeGrid(finds) {
            const container = document.getElementById('attributes-grid');
            if (!container) return;
            const attributeCounts = new Map();
            finds.forEach(find => {
                find.attributes.forEach(attr => {
                    const key = `${attr.id}_${attr.inc}`;
                    attributeCounts.set(key, (attributeCounts.get(key) || 0) + 1);
                });
            });

            let html = '<table><thead><tr><th>Attribuutti</th><th>Määrä</th></tr></thead><tbody>';
            
            const sortedAttrs = [...attributeMap.values()].sort((a,b) => a.name.localeCompare(b.name));

            sortedAttrs.forEach(attrData => {
                const key = `${attrData.id}_${attrData.inc}`;
                const count = attributeCounts.get(key) || 0;
                html += `<tr><td>${attrData.name}</td><td class="${count > 0 ? 'found' : 'not-found'}">${count > 0 ? count : ''}</td></tr>`;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

    </script>
</body>
</html>
